import { EventEmitter, ChangeDetectorRef, OnInit, OnDestroy } from '@angular/core';
import { ScrollerComponent } from './scroller.component';
import { SelectionType } from '../../types/selection.type';
import { RowHeightCache } from '../../utils/row-height-cache';
import * as ɵngcc0 from '@angular/core';
export declare class DataTableBodyComponent implements OnInit, OnDestroy {
    private cd;
    scrollbarV: boolean;
    scrollbarH: boolean;
    loadingIndicator: boolean;
    externalPaging: boolean;
    rowHeight: number | 'auto' | ((row?: any) => number);
    offsetX: number;
    emptyMessage: string;
    selectionType: SelectionType;
    selected: any[];
    rowIdentity: any;
    rowDetail: any;
    groupHeader: any;
    selectCheck: any;
    displayCheck: any;
    trackByProp: string;
    rowClass: any;
    groupedRows: any;
    groupExpansionDefault: boolean;
    innerWidth: number;
    groupRowsBy: string;
    virtualization: boolean;
    summaryRow: boolean;
    summaryPosition: string;
    summaryHeight: number;
    pageSize: number;
    rows: any[];
    columns: any[];
    offset: number;
    rowCount: number;
    readonly bodyWidth: string;
    bodyHeight: any;
    scroll: EventEmitter<any>;
    page: EventEmitter<any>;
    activate: EventEmitter<any>;
    select: EventEmitter<any>;
    detailToggle: EventEmitter<any>;
    rowContextmenu: EventEmitter<{
        event: MouseEvent;
        row: any;
    }>;
    treeAction: EventEmitter<any>;
    scroller: ScrollerComponent;
    /**
     * Returns if selection is enabled.
     */
    readonly selectEnabled: boolean;
    /**
     * Property that would calculate the height of scroll bar
     * based on the row heights cache for virtual scroll and virtualization. Other scenarios
     * calculate scroll height automatically (as height will be undefined).
     */
    readonly scrollHeight: number | undefined;
    rowHeightsCache: RowHeightCache;
    temp: any[];
    offsetY: number;
    indexes: any;
    columnGroupWidths: any;
    columnGroupWidthsWithoutGroup: any;
    rowTrackingFn: any;
    listener: any;
    rowIndexes: any;
    rowExpansions: any[];
    _rows: any[];
    _bodyHeight: any;
    _columns: any[];
    _rowCount: number;
    _offset: number;
    _pageSize: number;
    /**
     * Creates an instance of DataTableBodyComponent.
     */
    constructor(cd: ChangeDetectorRef);
    /**
     * Called after the constructor, initializing input properties
     */
    ngOnInit(): void;
    /**
     * Called once, before the instance is destroyed.
     */
    ngOnDestroy(): void;
    /**
     * Updates the Y offset given a new offset.
     */
    updateOffsetY(offset?: number): void;
    /**
     * Body was scrolled, this is mainly useful for
     * when a user is server-side pagination via virtual scroll.
     */
    onBodyScroll(event: any): void;
    /**
     * Updates the page given a direction.
     */
    updatePage(direction: string): void;
    /**
     * Updates the rows in the view port
     */
    updateRows(): void;
    /**
     * Get the row height
     */
    getRowHeight(row: any): number;
    /**
     * @param group the group with all rows
     */
    getGroupHeight(group: any): number;
    /**
     * Calculate row height based on the expanded state of the row.
     */
    getRowAndDetailHeight(row: any): number;
    /**
     * Get the height of the detail row.
     */
    getDetailRowHeight: (row?: any, index?: any) => number;
    /**
     * Calculates the styles for the row so that the rows can be moved in 2D space
     * during virtual scroll inside the DOM.   In the below case the Y position is
     * manipulated.   As an example, if the height of row 0 is 30 px and row 1 is
     * 100 px then following styles are generated:
     *
     * transform: translate3d(0px, 0px, 0px);    ->  row0
     * transform: translate3d(0px, 30px, 0px);   ->  row1
     * transform: translate3d(0px, 130px, 0px);  ->  row2
     *
     * Row heights have to be calculated based on the row heights cache as we wont
     * be able to determine which row is of what height before hand.  In the above
     * case the positionY of the translate3d for row2 would be the sum of all the
     * heights of the rows before it (i.e. row0 and row1).
     *
     * @param rows the row that needs to be placed in the 2D space.
     * @returns the CSS3 style to be applied
     *
     * @memberOf DataTableBodyComponent
     */
    getRowsStyles(rows: any): any;
    /**
     * Calculate bottom summary row offset for scrollbar mode.
     * For more information about cache and offset calculation
     * see description for `getRowsStyles` method
     *
     * @returns the CSS3 style to be applied
     *
     * @memberOf DataTableBodyComponent
     */
    getBottomSummaryRowStyles(): any;
    /**
     * Hides the loading indicator
     */
    hideIndicator(): void;
    /**
     * Updates the index of the rows in the viewport
     */
    updateIndexes(): void;
    /**
     * Refreshes the full Row Height cache.  Should be used
     * when the entire row array state has changed.
     */
    refreshRowHeightCache(): void;
    /**
     * Gets the index for the view port
     */
    getAdjustedViewPortIndex(): number;
    /**
     * Toggle the Expansion of the row i.e. if the row is expanded then it will
     * collapse and vice versa.   Note that the expanded status is stored as
     * a part of the row object itself as we have to preserve the expanded row
     * status in case of sorting and filtering of the row set.
     */
    toggleRowExpansion(row: any): void;
    /**
     * Expand/Collapse all the rows no matter what their state is.
     */
    toggleAllRows(expanded: boolean): void;
    /**
     * Recalculates the table
     */
    recalcLayout(): void;
    /**
     * Tracks the column
     */
    columnTrackingFn(index: number, column: any): any;
    /**
     * Gets the row pinning group styles
     */
    stylesByGroup(group: string): {
        width: string;
    };
    /**
     * Returns if the row was expanded and set default row expansion when row expansion is empty
     */
    getRowExpanded(row: any): boolean;
    getRowExpandedIdx(row: any, expanded: any[]): number;
    /**
     * Gets the row index given a row
     */
    getRowIndex(row: any): number;
    onTreeAction(row: any): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<DataTableBodyComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<DataTableBodyComponent, "datatable-body", never, { "selected": "selected"; "pageSize": "pageSize"; "rows": "rows"; "columns": "columns"; "offset": "offset"; "rowCount": "rowCount"; "bodyHeight": "bodyHeight"; "offsetX": "offsetX"; "loadingIndicator": "loadingIndicator"; "scrollbarV": "scrollbarV"; "scrollbarH": "scrollbarH"; "externalPaging": "externalPaging"; "rowHeight": "rowHeight"; "emptyMessage": "emptyMessage"; "selectionType": "selectionType"; "rowIdentity": "rowIdentity"; "rowDetail": "rowDetail"; "groupHeader": "groupHeader"; "selectCheck": "selectCheck"; "displayCheck": "displayCheck"; "trackByProp": "trackByProp"; "rowClass": "rowClass"; "groupedRows": "groupedRows"; "groupExpansionDefault": "groupExpansionDefault"; "innerWidth": "innerWidth"; "groupRowsBy": "groupRowsBy"; "virtualization": "virtualization"; "summaryRow": "summaryRow"; "summaryPosition": "summaryPosition"; "summaryHeight": "summaryHeight"; }, { "scroll": "scroll"; "page": "page"; "activate": "activate"; "select": "select"; "detailToggle": "detailToggle"; "rowContextmenu": "rowContextmenu"; "treeAction": "treeAction"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYm9keS5jb21wb25lbnQuZC50cyIsInNvdXJjZXMiOlsiYm9keS5jb21wb25lbnQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRFbWl0dGVyLCBDaGFuZ2VEZXRlY3RvclJlZiwgT25Jbml0LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFNjcm9sbGVyQ29tcG9uZW50IH0gZnJvbSAnLi9zY3JvbGxlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgU2VsZWN0aW9uVHlwZSB9IGZyb20gJy4uLy4uL3R5cGVzL3NlbGVjdGlvbi50eXBlJztcbmltcG9ydCB7IFJvd0hlaWdodENhY2hlIH0gZnJvbSAnLi4vLi4vdXRpbHMvcm93LWhlaWdodC1jYWNoZSc7XG5leHBvcnQgZGVjbGFyZSBjbGFzcyBEYXRhVGFibGVCb2R5Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgY2Q7XG4gICAgc2Nyb2xsYmFyVjogYm9vbGVhbjtcbiAgICBzY3JvbGxiYXJIOiBib29sZWFuO1xuICAgIGxvYWRpbmdJbmRpY2F0b3I6IGJvb2xlYW47XG4gICAgZXh0ZXJuYWxQYWdpbmc6IGJvb2xlYW47XG4gICAgcm93SGVpZ2h0OiBudW1iZXIgfCAnYXV0bycgfCAoKHJvdz86IGFueSkgPT4gbnVtYmVyKTtcbiAgICBvZmZzZXRYOiBudW1iZXI7XG4gICAgZW1wdHlNZXNzYWdlOiBzdHJpbmc7XG4gICAgc2VsZWN0aW9uVHlwZTogU2VsZWN0aW9uVHlwZTtcbiAgICBzZWxlY3RlZDogYW55W107XG4gICAgcm93SWRlbnRpdHk6IGFueTtcbiAgICByb3dEZXRhaWw6IGFueTtcbiAgICBncm91cEhlYWRlcjogYW55O1xuICAgIHNlbGVjdENoZWNrOiBhbnk7XG4gICAgZGlzcGxheUNoZWNrOiBhbnk7XG4gICAgdHJhY2tCeVByb3A6IHN0cmluZztcbiAgICByb3dDbGFzczogYW55O1xuICAgIGdyb3VwZWRSb3dzOiBhbnk7XG4gICAgZ3JvdXBFeHBhbnNpb25EZWZhdWx0OiBib29sZWFuO1xuICAgIGlubmVyV2lkdGg6IG51bWJlcjtcbiAgICBncm91cFJvd3NCeTogc3RyaW5nO1xuICAgIHZpcnR1YWxpemF0aW9uOiBib29sZWFuO1xuICAgIHN1bW1hcnlSb3c6IGJvb2xlYW47XG4gICAgc3VtbWFyeVBvc2l0aW9uOiBzdHJpbmc7XG4gICAgc3VtbWFyeUhlaWdodDogbnVtYmVyO1xuICAgIHBhZ2VTaXplOiBudW1iZXI7XG4gICAgcm93czogYW55W107XG4gICAgY29sdW1uczogYW55W107XG4gICAgb2Zmc2V0OiBudW1iZXI7XG4gICAgcm93Q291bnQ6IG51bWJlcjtcbiAgICByZWFkb25seSBib2R5V2lkdGg6IHN0cmluZztcbiAgICBib2R5SGVpZ2h0OiBhbnk7XG4gICAgc2Nyb2xsOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICBwYWdlOiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICBhY3RpdmF0ZTogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgc2VsZWN0OiBFdmVudEVtaXR0ZXI8YW55PjtcbiAgICBkZXRhaWxUb2dnbGU6IEV2ZW50RW1pdHRlcjxhbnk+O1xuICAgIHJvd0NvbnRleHRtZW51OiBFdmVudEVtaXR0ZXI8e1xuICAgICAgICBldmVudDogTW91c2VFdmVudDtcbiAgICAgICAgcm93OiBhbnk7XG4gICAgfT47XG4gICAgdHJlZUFjdGlvbjogRXZlbnRFbWl0dGVyPGFueT47XG4gICAgc2Nyb2xsZXI6IFNjcm9sbGVyQ29tcG9uZW50O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgc2VsZWN0aW9uIGlzIGVuYWJsZWQuXG4gICAgICovXG4gICAgcmVhZG9ubHkgc2VsZWN0RW5hYmxlZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0eSB0aGF0IHdvdWxkIGNhbGN1bGF0ZSB0aGUgaGVpZ2h0IG9mIHNjcm9sbCBiYXJcbiAgICAgKiBiYXNlZCBvbiB0aGUgcm93IGhlaWdodHMgY2FjaGUgZm9yIHZpcnR1YWwgc2Nyb2xsIGFuZCB2aXJ0dWFsaXphdGlvbi4gT3RoZXIgc2NlbmFyaW9zXG4gICAgICogY2FsY3VsYXRlIHNjcm9sbCBoZWlnaHQgYXV0b21hdGljYWxseSAoYXMgaGVpZ2h0IHdpbGwgYmUgdW5kZWZpbmVkKS5cbiAgICAgKi9cbiAgICByZWFkb25seSBzY3JvbGxIZWlnaHQ6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgICByb3dIZWlnaHRzQ2FjaGU6IFJvd0hlaWdodENhY2hlO1xuICAgIHRlbXA6IGFueVtdO1xuICAgIG9mZnNldFk6IG51bWJlcjtcbiAgICBpbmRleGVzOiBhbnk7XG4gICAgY29sdW1uR3JvdXBXaWR0aHM6IGFueTtcbiAgICBjb2x1bW5Hcm91cFdpZHRoc1dpdGhvdXRHcm91cDogYW55O1xuICAgIHJvd1RyYWNraW5nRm46IGFueTtcbiAgICBsaXN0ZW5lcjogYW55O1xuICAgIHJvd0luZGV4ZXM6IGFueTtcbiAgICByb3dFeHBhbnNpb25zOiBhbnlbXTtcbiAgICBfcm93czogYW55W107XG4gICAgX2JvZHlIZWlnaHQ6IGFueTtcbiAgICBfY29sdW1uczogYW55W107XG4gICAgX3Jvd0NvdW50OiBudW1iZXI7XG4gICAgX29mZnNldDogbnVtYmVyO1xuICAgIF9wYWdlU2l6ZTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgRGF0YVRhYmxlQm9keUNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjZDogQ2hhbmdlRGV0ZWN0b3JSZWYpO1xuICAgIC8qKlxuICAgICAqIENhbGxlZCBhZnRlciB0aGUgY29uc3RydWN0b3IsIGluaXRpYWxpemluZyBpbnB1dCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgb25jZSwgYmVmb3JlIHRoZSBpbnN0YW5jZSBpcyBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBZIG9mZnNldCBnaXZlbiBhIG5ldyBvZmZzZXQuXG4gICAgICovXG4gICAgdXBkYXRlT2Zmc2V0WShvZmZzZXQ/OiBudW1iZXIpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEJvZHkgd2FzIHNjcm9sbGVkLCB0aGlzIGlzIG1haW5seSB1c2VmdWwgZm9yXG4gICAgICogd2hlbiBhIHVzZXIgaXMgc2VydmVyLXNpZGUgcGFnaW5hdGlvbiB2aWEgdmlydHVhbCBzY3JvbGwuXG4gICAgICovXG4gICAgb25Cb2R5U2Nyb2xsKGV2ZW50OiBhbnkpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHBhZ2UgZ2l2ZW4gYSBkaXJlY3Rpb24uXG4gICAgICovXG4gICAgdXBkYXRlUGFnZShkaXJlY3Rpb246IHN0cmluZyk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcm93cyBpbiB0aGUgdmlldyBwb3J0XG4gICAgICovXG4gICAgdXBkYXRlUm93cygpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcm93IGhlaWdodFxuICAgICAqL1xuICAgIGdldFJvd0hlaWdodChyb3c6IGFueSk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZ3JvdXAgdGhlIGdyb3VwIHdpdGggYWxsIHJvd3NcbiAgICAgKi9cbiAgICBnZXRHcm91cEhlaWdodChncm91cDogYW55KTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSByb3cgaGVpZ2h0IGJhc2VkIG9uIHRoZSBleHBhbmRlZCBzdGF0ZSBvZiB0aGUgcm93LlxuICAgICAqL1xuICAgIGdldFJvd0FuZERldGFpbEhlaWdodChyb3c6IGFueSk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGhlaWdodCBvZiB0aGUgZGV0YWlsIHJvdy5cbiAgICAgKi9cbiAgICBnZXREZXRhaWxSb3dIZWlnaHQ6IChyb3c/OiBhbnksIGluZGV4PzogYW55KSA9PiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgc3R5bGVzIGZvciB0aGUgcm93IHNvIHRoYXQgdGhlIHJvd3MgY2FuIGJlIG1vdmVkIGluIDJEIHNwYWNlXG4gICAgICogZHVyaW5nIHZpcnR1YWwgc2Nyb2xsIGluc2lkZSB0aGUgRE9NLiAgIEluIHRoZSBiZWxvdyBjYXNlIHRoZSBZIHBvc2l0aW9uIGlzXG4gICAgICogbWFuaXB1bGF0ZWQuICAgQXMgYW4gZXhhbXBsZSwgaWYgdGhlIGhlaWdodCBvZiByb3cgMCBpcyAzMCBweCBhbmQgcm93IDEgaXNcbiAgICAgKiAxMDAgcHggdGhlbiBmb2xsb3dpbmcgc3R5bGVzIGFyZSBnZW5lcmF0ZWQ6XG4gICAgICpcbiAgICAgKiB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDBweCwgMHB4LCAwcHgpOyAgICAtPiAgcm93MFxuICAgICAqIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMHB4LCAzMHB4LCAwcHgpOyAgIC0+ICByb3cxXG4gICAgICogdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwcHgsIDEzMHB4LCAwcHgpOyAgLT4gIHJvdzJcbiAgICAgKlxuICAgICAqIFJvdyBoZWlnaHRzIGhhdmUgdG8gYmUgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgcm93IGhlaWdodHMgY2FjaGUgYXMgd2Ugd29udFxuICAgICAqIGJlIGFibGUgdG8gZGV0ZXJtaW5lIHdoaWNoIHJvdyBpcyBvZiB3aGF0IGhlaWdodCBiZWZvcmUgaGFuZC4gIEluIHRoZSBhYm92ZVxuICAgICAqIGNhc2UgdGhlIHBvc2l0aW9uWSBvZiB0aGUgdHJhbnNsYXRlM2QgZm9yIHJvdzIgd291bGQgYmUgdGhlIHN1bSBvZiBhbGwgdGhlXG4gICAgICogaGVpZ2h0cyBvZiB0aGUgcm93cyBiZWZvcmUgaXQgKGkuZS4gcm93MCBhbmQgcm93MSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm93cyB0aGUgcm93IHRoYXQgbmVlZHMgdG8gYmUgcGxhY2VkIGluIHRoZSAyRCBzcGFjZS5cbiAgICAgKiBAcmV0dXJucyB0aGUgQ1NTMyBzdHlsZSB0byBiZSBhcHBsaWVkXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVRhYmxlQm9keUNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldFJvd3NTdHlsZXMocm93czogYW55KTogYW55O1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBib3R0b20gc3VtbWFyeSByb3cgb2Zmc2V0IGZvciBzY3JvbGxiYXIgbW9kZS5cbiAgICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCBjYWNoZSBhbmQgb2Zmc2V0IGNhbGN1bGF0aW9uXG4gICAgICogc2VlIGRlc2NyaXB0aW9uIGZvciBgZ2V0Um93c1N0eWxlc2AgbWV0aG9kXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgQ1NTMyBzdHlsZSB0byBiZSBhcHBsaWVkXG4gICAgICpcbiAgICAgKiBAbWVtYmVyT2YgRGF0YVRhYmxlQm9keUNvbXBvbmVudFxuICAgICAqL1xuICAgIGdldEJvdHRvbVN1bW1hcnlSb3dTdHlsZXMoKTogYW55O1xuICAgIC8qKlxuICAgICAqIEhpZGVzIHRoZSBsb2FkaW5nIGluZGljYXRvclxuICAgICAqL1xuICAgIGhpZGVJbmRpY2F0b3IoKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBpbmRleCBvZiB0aGUgcm93cyBpbiB0aGUgdmlld3BvcnRcbiAgICAgKi9cbiAgICB1cGRhdGVJbmRleGVzKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSBmdWxsIFJvdyBIZWlnaHQgY2FjaGUuICBTaG91bGQgYmUgdXNlZFxuICAgICAqIHdoZW4gdGhlIGVudGlyZSByb3cgYXJyYXkgc3RhdGUgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgcmVmcmVzaFJvd0hlaWdodENhY2hlKCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5kZXggZm9yIHRoZSB2aWV3IHBvcnRcbiAgICAgKi9cbiAgICBnZXRBZGp1c3RlZFZpZXdQb3J0SW5kZXgoKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFRvZ2dsZSB0aGUgRXhwYW5zaW9uIG9mIHRoZSByb3cgaS5lLiBpZiB0aGUgcm93IGlzIGV4cGFuZGVkIHRoZW4gaXQgd2lsbFxuICAgICAqIGNvbGxhcHNlIGFuZCB2aWNlIHZlcnNhLiAgIE5vdGUgdGhhdCB0aGUgZXhwYW5kZWQgc3RhdHVzIGlzIHN0b3JlZCBhc1xuICAgICAqIGEgcGFydCBvZiB0aGUgcm93IG9iamVjdCBpdHNlbGYgYXMgd2UgaGF2ZSB0byBwcmVzZXJ2ZSB0aGUgZXhwYW5kZWQgcm93XG4gICAgICogc3RhdHVzIGluIGNhc2Ugb2Ygc29ydGluZyBhbmQgZmlsdGVyaW5nIG9mIHRoZSByb3cgc2V0LlxuICAgICAqL1xuICAgIHRvZ2dsZVJvd0V4cGFuc2lvbihyb3c6IGFueSk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogRXhwYW5kL0NvbGxhcHNlIGFsbCB0aGUgcm93cyBubyBtYXR0ZXIgd2hhdCB0aGVpciBzdGF0ZSBpcy5cbiAgICAgKi9cbiAgICB0b2dnbGVBbGxSb3dzKGV4cGFuZGVkOiBib29sZWFuKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZXMgdGhlIHRhYmxlXG4gICAgICovXG4gICAgcmVjYWxjTGF5b3V0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogVHJhY2tzIHRoZSBjb2x1bW5cbiAgICAgKi9cbiAgICBjb2x1bW5UcmFja2luZ0ZuKGluZGV4OiBudW1iZXIsIGNvbHVtbjogYW55KTogYW55O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHJvdyBwaW5uaW5nIGdyb3VwIHN0eWxlc1xuICAgICAqL1xuICAgIHN0eWxlc0J5R3JvdXAoZ3JvdXA6IHN0cmluZyk6IHtcbiAgICAgICAgd2lkdGg6IHN0cmluZztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIHJvdyB3YXMgZXhwYW5kZWQgYW5kIHNldCBkZWZhdWx0IHJvdyBleHBhbnNpb24gd2hlbiByb3cgZXhwYW5zaW9uIGlzIGVtcHR5XG4gICAgICovXG4gICAgZ2V0Um93RXhwYW5kZWQocm93OiBhbnkpOiBib29sZWFuO1xuICAgIGdldFJvd0V4cGFuZGVkSWR4KHJvdzogYW55LCBleHBhbmRlZDogYW55W10pOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcm93IGluZGV4IGdpdmVuIGEgcm93XG4gICAgICovXG4gICAgZ2V0Um93SW5kZXgocm93OiBhbnkpOiBudW1iZXI7XG4gICAgb25UcmVlQWN0aW9uKHJvdzogYW55KTogdm9pZDtcbn1cbiJdfQ==