import { OnInit, ElementRef, Renderer2, EventEmitter, OnDestroy, OnChanges, NgZone, SimpleChanges, TemplateRef, ViewContainerRef } from '@angular/core';
import { Subject, ReplaySubject } from 'rxjs';
import { DraggableHelper } from './draggable-helper.provider';
import { DraggableScrollContainerDirective } from './draggable-scroll-container.directive';
import * as ɵngcc0 from '@angular/core';
export interface Coordinates {
    x: number;
    y: number;
}
export interface DragAxis {
    x: boolean;
    y: boolean;
}
export interface SnapGrid {
    x?: number;
    y?: number;
}
export interface DragPointerDownEvent extends Coordinates {
}
export interface DragStartEvent {
    cancelDrag$: ReplaySubject<void>;
}
export interface DragMoveEvent extends Coordinates {
}
export interface DragEndEvent extends Coordinates {
    dragCancelled: boolean;
}
export interface ValidateDragParams extends Coordinates {
    transform: {
        x: number;
        y: number;
    };
}
export declare type ValidateDrag = (params: ValidateDragParams) => boolean;
export interface PointerEvent {
    clientX: number;
    clientY: number;
    event: MouseEvent | TouchEvent;
}
export interface TimeLongPress {
    timerBegin: number;
    timerEnd: number;
}
export interface GhostElementCreatedEvent {
    clientX: number;
    clientY: number;
    element: HTMLElement;
}
export declare class DraggableDirective implements OnInit, OnChanges, OnDestroy {
    private element;
    private renderer;
    private draggableHelper;
    private zone;
    private vcr;
    private scrollContainer;
    private document;
    /**
     * an object of data you can pass to the drop event
     */
    dropData: any;
    /**
     * The axis along which the element is draggable
     */
    dragAxis: DragAxis;
    /**
     * Snap all drags to an x / y grid
     */
    dragSnapGrid: SnapGrid;
    /**
     * Show a ghost element that shows the drag when dragging
     */
    ghostDragEnabled: boolean;
    /**
     * Show the original element when ghostDragEnabled is true
     */
    showOriginalElementWhileDragging: boolean;
    /**
     * Allow custom behaviour to control when the element is dragged
     */
    validateDrag: ValidateDrag;
    /**
     * The cursor to use when hovering over a draggable element
     */
    dragCursor: string;
    /**
     * The css class to apply when the element is being dragged
     */
    dragActiveClass: string;
    /**
     * The element the ghost element will be appended to. Default is next to the dragged element
     */
    ghostElementAppendTo: HTMLElement;
    /**
     * An ng-template to be inserted into the parent element of the ghost element. It will overwrite any child nodes.
     */
    ghostElementTemplate: TemplateRef<any>;
    /**
     * Called when the element can be dragged along one axis and has the mouse or pointer device pressed on it
     */
    dragPointerDown: EventEmitter<DragPointerDownEvent>;
    /**
     * Called when the element has started to be dragged.
     * Only called after at least one mouse or touch move event.
     * If you call $event.cancelDrag$.emit() it will cancel the current drag
     */
    dragStart: EventEmitter<DragStartEvent>;
    /**
     * Called after the ghost element has been created
     */
    ghostElementCreated: EventEmitter<GhostElementCreatedEvent>;
    /**
     * Called when the element is being dragged
     */
    dragging: EventEmitter<DragMoveEvent>;
    /**
     * Called after the element is dragged
     */
    dragEnd: EventEmitter<DragEndEvent>;
    /**
     * @hidden
     */
    pointerDown$: Subject<PointerEvent>;
    /**
     * @hidden
     */
    pointerMove$: Subject<PointerEvent>;
    /**
     * @hidden
     */
    pointerUp$: Subject<PointerEvent>;
    private eventListenerSubscriptions;
    private ghostElement;
    private destroy$;
    private timeLongPress;
    private scroller;
    /**
     * @hidden
     */
    constructor(element: ElementRef<HTMLElement>, renderer: Renderer2, draggableHelper: DraggableHelper, zone: NgZone, vcr: ViewContainerRef, scrollContainer: DraggableScrollContainerDirective, document: any);
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    private checkEventListeners;
    private onMouseDown;
    private onMouseUp;
    private onTouchStart;
    private onTouchEnd;
    private onMouseEnter;
    private onMouseLeave;
    private canDrag;
    private setCursor;
    private unsubscribeEventListeners;
    private setElementStyles;
    private getScrollPosition;
    private shouldBeginDrag;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<DraggableDirective, [null, null, null, null, null, { optional: true; }, null]>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<DraggableDirective, "[mwlDraggable]", never, { "dragAxis": "dragAxis"; "dragSnapGrid": "dragSnapGrid"; "ghostDragEnabled": "ghostDragEnabled"; "showOriginalElementWhileDragging": "showOriginalElementWhileDragging"; "dragCursor": "dragCursor"; "dropData": "dropData"; "validateDrag": "validateDrag"; "dragActiveClass": "dragActiveClass"; "ghostElementAppendTo": "ghostElementAppendTo"; "ghostElementTemplate": "ghostElementTemplate"; }, { "dragPointerDown": "dragPointerDown"; "dragStart": "dragStart"; "ghostElementCreated": "ghostElementCreated"; "dragging": "dragging"; "dragEnd": "dragEnd"; }, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhZ2dhYmxlLmRpcmVjdGl2ZS5kLnRzIiwic291cmNlcyI6WyJkcmFnZ2FibGUuZGlyZWN0aXZlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9uSW5pdCwgRWxlbWVudFJlZiwgUmVuZGVyZXIyLCBFdmVudEVtaXR0ZXIsIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBOZ1pvbmUsIFNpbXBsZUNoYW5nZXMsIFRlbXBsYXRlUmVmLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0LCBSZXBsYXlTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBEcmFnZ2FibGVIZWxwZXIgfSBmcm9tICcuL2RyYWdnYWJsZS1oZWxwZXIucHJvdmlkZXInO1xuaW1wb3J0IHsgRHJhZ2dhYmxlU2Nyb2xsQ29udGFpbmVyRGlyZWN0aXZlIH0gZnJvbSAnLi9kcmFnZ2FibGUtc2Nyb2xsLWNvbnRhaW5lci5kaXJlY3RpdmUnO1xuZXhwb3J0IGludGVyZmFjZSBDb29yZGluYXRlcyB7XG4gICAgeDogbnVtYmVyO1xuICAgIHk6IG51bWJlcjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgRHJhZ0F4aXMge1xuICAgIHg6IGJvb2xlYW47XG4gICAgeTogYm9vbGVhbjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgU25hcEdyaWQge1xuICAgIHg/OiBudW1iZXI7XG4gICAgeT86IG51bWJlcjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgRHJhZ1BvaW50ZXJEb3duRXZlbnQgZXh0ZW5kcyBDb29yZGluYXRlcyB7XG59XG5leHBvcnQgaW50ZXJmYWNlIERyYWdTdGFydEV2ZW50IHtcbiAgICBjYW5jZWxEcmFnJDogUmVwbGF5U3ViamVjdDx2b2lkPjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgRHJhZ01vdmVFdmVudCBleHRlbmRzIENvb3JkaW5hdGVzIHtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgRHJhZ0VuZEV2ZW50IGV4dGVuZHMgQ29vcmRpbmF0ZXMge1xuICAgIGRyYWdDYW5jZWxsZWQ6IGJvb2xlYW47XG59XG5leHBvcnQgaW50ZXJmYWNlIFZhbGlkYXRlRHJhZ1BhcmFtcyBleHRlbmRzIENvb3JkaW5hdGVzIHtcbiAgICB0cmFuc2Zvcm06IHtcbiAgICAgICAgeDogbnVtYmVyO1xuICAgICAgICB5OiBudW1iZXI7XG4gICAgfTtcbn1cbmV4cG9ydCBkZWNsYXJlIHR5cGUgVmFsaWRhdGVEcmFnID0gKHBhcmFtczogVmFsaWRhdGVEcmFnUGFyYW1zKSA9PiBib29sZWFuO1xuZXhwb3J0IGludGVyZmFjZSBQb2ludGVyRXZlbnQge1xuICAgIGNsaWVudFg6IG51bWJlcjtcbiAgICBjbGllbnRZOiBudW1iZXI7XG4gICAgZXZlbnQ6IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50O1xufVxuZXhwb3J0IGludGVyZmFjZSBUaW1lTG9uZ1ByZXNzIHtcbiAgICB0aW1lckJlZ2luOiBudW1iZXI7XG4gICAgdGltZXJFbmQ6IG51bWJlcjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgR2hvc3RFbGVtZW50Q3JlYXRlZEV2ZW50IHtcbiAgICBjbGllbnRYOiBudW1iZXI7XG4gICAgY2xpZW50WTogbnVtYmVyO1xuICAgIGVsZW1lbnQ6IEhUTUxFbGVtZW50O1xufVxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgRHJhZ2dhYmxlRGlyZWN0aXZlIGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBlbGVtZW50O1xuICAgIHByaXZhdGUgcmVuZGVyZXI7XG4gICAgcHJpdmF0ZSBkcmFnZ2FibGVIZWxwZXI7XG4gICAgcHJpdmF0ZSB6b25lO1xuICAgIHByaXZhdGUgdmNyO1xuICAgIHByaXZhdGUgc2Nyb2xsQ29udGFpbmVyO1xuICAgIHByaXZhdGUgZG9jdW1lbnQ7XG4gICAgLyoqXG4gICAgICogYW4gb2JqZWN0IG9mIGRhdGEgeW91IGNhbiBwYXNzIHRvIHRoZSBkcm9wIGV2ZW50XG4gICAgICovXG4gICAgZHJvcERhdGE6IGFueTtcbiAgICAvKipcbiAgICAgKiBUaGUgYXhpcyBhbG9uZyB3aGljaCB0aGUgZWxlbWVudCBpcyBkcmFnZ2FibGVcbiAgICAgKi9cbiAgICBkcmFnQXhpczogRHJhZ0F4aXM7XG4gICAgLyoqXG4gICAgICogU25hcCBhbGwgZHJhZ3MgdG8gYW4geCAvIHkgZ3JpZFxuICAgICAqL1xuICAgIGRyYWdTbmFwR3JpZDogU25hcEdyaWQ7XG4gICAgLyoqXG4gICAgICogU2hvdyBhIGdob3N0IGVsZW1lbnQgdGhhdCBzaG93cyB0aGUgZHJhZyB3aGVuIGRyYWdnaW5nXG4gICAgICovXG4gICAgZ2hvc3REcmFnRW5hYmxlZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSBvcmlnaW5hbCBlbGVtZW50IHdoZW4gZ2hvc3REcmFnRW5hYmxlZCBpcyB0cnVlXG4gICAgICovXG4gICAgc2hvd09yaWdpbmFsRWxlbWVudFdoaWxlRHJhZ2dpbmc6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQWxsb3cgY3VzdG9tIGJlaGF2aW91ciB0byBjb250cm9sIHdoZW4gdGhlIGVsZW1lbnQgaXMgZHJhZ2dlZFxuICAgICAqL1xuICAgIHZhbGlkYXRlRHJhZzogVmFsaWRhdGVEcmFnO1xuICAgIC8qKlxuICAgICAqIFRoZSBjdXJzb3IgdG8gdXNlIHdoZW4gaG92ZXJpbmcgb3ZlciBhIGRyYWdnYWJsZSBlbGVtZW50XG4gICAgICovXG4gICAgZHJhZ0N1cnNvcjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBjc3MgY2xhc3MgdG8gYXBwbHkgd2hlbiB0aGUgZWxlbWVudCBpcyBiZWluZyBkcmFnZ2VkXG4gICAgICovXG4gICAgZHJhZ0FjdGl2ZUNsYXNzOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIGVsZW1lbnQgdGhlIGdob3N0IGVsZW1lbnQgd2lsbCBiZSBhcHBlbmRlZCB0by4gRGVmYXVsdCBpcyBuZXh0IHRvIHRoZSBkcmFnZ2VkIGVsZW1lbnRcbiAgICAgKi9cbiAgICBnaG9zdEVsZW1lbnRBcHBlbmRUbzogSFRNTEVsZW1lbnQ7XG4gICAgLyoqXG4gICAgICogQW4gbmctdGVtcGxhdGUgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgcGFyZW50IGVsZW1lbnQgb2YgdGhlIGdob3N0IGVsZW1lbnQuIEl0IHdpbGwgb3ZlcndyaXRlIGFueSBjaGlsZCBub2Rlcy5cbiAgICAgKi9cbiAgICBnaG9zdEVsZW1lbnRUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgZWxlbWVudCBjYW4gYmUgZHJhZ2dlZCBhbG9uZyBvbmUgYXhpcyBhbmQgaGFzIHRoZSBtb3VzZSBvciBwb2ludGVyIGRldmljZSBwcmVzc2VkIG9uIGl0XG4gICAgICovXG4gICAgZHJhZ1BvaW50ZXJEb3duOiBFdmVudEVtaXR0ZXI8RHJhZ1BvaW50ZXJEb3duRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBlbGVtZW50IGhhcyBzdGFydGVkIHRvIGJlIGRyYWdnZWQuXG4gICAgICogT25seSBjYWxsZWQgYWZ0ZXIgYXQgbGVhc3Qgb25lIG1vdXNlIG9yIHRvdWNoIG1vdmUgZXZlbnQuXG4gICAgICogSWYgeW91IGNhbGwgJGV2ZW50LmNhbmNlbERyYWckLmVtaXQoKSBpdCB3aWxsIGNhbmNlbCB0aGUgY3VycmVudCBkcmFnXG4gICAgICovXG4gICAgZHJhZ1N0YXJ0OiBFdmVudEVtaXR0ZXI8RHJhZ1N0YXJ0RXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCBhZnRlciB0aGUgZ2hvc3QgZWxlbWVudCBoYXMgYmVlbiBjcmVhdGVkXG4gICAgICovXG4gICAgZ2hvc3RFbGVtZW50Q3JlYXRlZDogRXZlbnRFbWl0dGVyPEdob3N0RWxlbWVudENyZWF0ZWRFdmVudD47XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGVsZW1lbnQgaXMgYmVpbmcgZHJhZ2dlZFxuICAgICAqL1xuICAgIGRyYWdnaW5nOiBFdmVudEVtaXR0ZXI8RHJhZ01vdmVFdmVudD47XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGFmdGVyIHRoZSBlbGVtZW50IGlzIGRyYWdnZWRcbiAgICAgKi9cbiAgICBkcmFnRW5kOiBFdmVudEVtaXR0ZXI8RHJhZ0VuZEV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcG9pbnRlckRvd24kOiBTdWJqZWN0PFBvaW50ZXJFdmVudD47XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHBvaW50ZXJNb3ZlJDogU3ViamVjdDxQb2ludGVyRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwb2ludGVyVXAkOiBTdWJqZWN0PFBvaW50ZXJFdmVudD47XG4gICAgcHJpdmF0ZSBldmVudExpc3RlbmVyU3Vic2NyaXB0aW9ucztcbiAgICBwcml2YXRlIGdob3N0RWxlbWVudDtcbiAgICBwcml2YXRlIGRlc3Ryb3kkO1xuICAgIHByaXZhdGUgdGltZUxvbmdQcmVzcztcbiAgICBwcml2YXRlIHNjcm9sbGVyO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PiwgcmVuZGVyZXI6IFJlbmRlcmVyMiwgZHJhZ2dhYmxlSGVscGVyOiBEcmFnZ2FibGVIZWxwZXIsIHpvbmU6IE5nWm9uZSwgdmNyOiBWaWV3Q29udGFpbmVyUmVmLCBzY3JvbGxDb250YWluZXI6IERyYWdnYWJsZVNjcm9sbENvbnRhaW5lckRpcmVjdGl2ZSwgZG9jdW1lbnQ6IGFueSk7XG4gICAgbmdPbkluaXQoKTogdm9pZDtcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIHByaXZhdGUgY2hlY2tFdmVudExpc3RlbmVycztcbiAgICBwcml2YXRlIG9uTW91c2VEb3duO1xuICAgIHByaXZhdGUgb25Nb3VzZVVwO1xuICAgIHByaXZhdGUgb25Ub3VjaFN0YXJ0O1xuICAgIHByaXZhdGUgb25Ub3VjaEVuZDtcbiAgICBwcml2YXRlIG9uTW91c2VFbnRlcjtcbiAgICBwcml2YXRlIG9uTW91c2VMZWF2ZTtcbiAgICBwcml2YXRlIGNhbkRyYWc7XG4gICAgcHJpdmF0ZSBzZXRDdXJzb3I7XG4gICAgcHJpdmF0ZSB1bnN1YnNjcmliZUV2ZW50TGlzdGVuZXJzO1xuICAgIHByaXZhdGUgc2V0RWxlbWVudFN0eWxlcztcbiAgICBwcml2YXRlIGdldFNjcm9sbFBvc2l0aW9uO1xuICAgIHByaXZhdGUgc2hvdWxkQmVnaW5EcmFnO1xufVxuIl19